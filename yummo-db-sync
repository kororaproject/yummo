#!/usr/bin/perl
#

use feature ':5.10';


use Carp;
use DBI;
use Fcntl qw( :DEFAULT );
use File::Basename;
use File::Path qw(make_path);
use IO::Uncompress::Bunzip2 qw(bunzip2);
use IO::Uncompress::Gunzip qw(gunzip);
use Mojo::DOM;
use Mojo::UserAgent;

use Data::Dumper;

$ENV{MOJO_MAX_MESSAGE_SIZE} = 1073741824;
my $NO_SSL = $ENV{NO_SSL} // 0;

my $ua = Mojo::UserAgent->new();

my $path = "./repos";

my $REPOS = {
  'adobe' => {
    url => 'http://linuxdownload.adobe.com/linux/$basearch/',
    type => 'baseurl',
    archs => ['i386', 'x86_64'],
    releases => [18, 19]
  },
  'fedora' => {
    url => 'http://mirrors.fedoraproject.org/metalink?repo=fedora-$releasever&arch=$basearch',
    type => 'mirror-xml',
    archs => ['i386', 'x86_64'],
    releases => [18, 19]
  },
  'fedora-updates' => {
    url => 'http://mirrors.fedoraproject.org/metalink?repo=fedora-$releasever&arch=$basearch',
    type => 'mirror-xml',
    archs => ['i386', 'x86_64'],
    releases => [18, 19]
  },
  'google-chrome' => {
    url => 'http://dl.google.com/linux/chrome/rpm/stable/$basearch/',
    type => 'baseurl',
    archs => ['i386', 'x86_64'],
    releases => [18, 19]
  },
  'google-earth' => {
    url => 'http://dl.google.com/linux/earth/rpm/stable/$basearch/',
    type => 'baseurl',
    archs => ['i386', 'x86_64'],
    releases => [18, 19]
  },
  'google-talkplugin' => {
    url => 'http://dl.google.com/linux/talkplugin/rpm/stable/$basearch/',
    type => 'baseurl',
    archs => ['i386', 'x86_64'],
    releases => [18, 19]
  },
  'korora' => {
    url => 'http://dl.kororaproject.org/pub/korora/releases/$releasever/$basearch/',
    type => 'baseurl',
    archs => ['i386', 'x86_64'],
    releases => [18, 19]
  },
  'rpmfusion-free' => {
    url => 'http://mirrors.rpmfusion.org/mirrorlist?repo=free-fedora-$releasever&arch=$basearch',
    type => 'mirror-plain',
    archs => ['i386', 'x86_64'],
    releases => [18, 19]
  },
  'rpmfusion-free-updates' => {
    url => 'http://mirrors.rpmfusion.org/mirrorlist?repo=free-fedora-updates-released-$releasever&arch=$basearch',
    type => 'mirror-plain',
    archs => ['i386', 'x86_64'],
    releases => [18, 19]
  },
  'rpmfusion-nonfree' => {
    url => 'http://mirrors.rpmfusion.org/mirrorlist?repo=nonfree-fedora-$releasever&arch=$basearch',
    type => 'mirror-plain',
    archs => ['i386', 'x86_64'],
    releases => [18, 19]
  },
  'rpmfusion-nonfree-updates' => {
    url => 'http://mirrors.rpmfusion.org/mirrorlist?repo=nonfree-fedora-updates-released-$releasever&arch=$basearch',
    type => 'mirror-plain',
    archs => ['i386', 'x86_64'],
    releases => [18, 19]
  },
};






# fas
sub slurp {
  my( $file_name, %args ) = @_;

  my $buf = "";
  my $buf_ref = \$buf;

  my $mode = O_RDONLY;

  local( *FH );
  sysopen( FH, $file_name, $mode ) or carp "Can't open $file_name: $!" ;

  my $size_left = -s FH;

  while( $size_left > 0 ) {

    my $read_cnt = sysread( FH, ${$buf_ref}, $size_left, length ${$buf_ref} );

    unless( $read_cnt ) {
      carp "read error in file $file_name: $!";
      last;
    }

    $size_left -= $read_cnt;
  }

  # handle scalar context
  return ${$buf_ref};
}

sub convert {
  my( $file, $db_path ) = @_;

  die "Can't read primary XML." unless -r $file;

  # slurp up the file contents
  say "Slurping XML ...";
  my $dom = Mojo::DOM->new->parse( slurp $file );
  $dom->xml(1);

  # check DB doesn't exist
  if( -r $db_path ) {
    say "DB already exists. Removing ...";
    unlink $db_path or die "Unable to remove.";
  }

  # create DB
  say "Creating database ...";
  my $dbh = DBI->connect("dbi:SQLite:dbname=" . $db_path, "", "") or die "Can't create DB: $db_path";
  $dbh->do("CREATE TABLE db_info (dbversion INTEGER, checksum TEXT);");
  $dbh->do("CREATE TABLE packages (pkgKey INTEGER PRIMARY KEY, pkgId TEXT, name TEXT, arch TEXT, version TEXT, epoch TEXT, release TEXT, summary TEXT, description TEXT, url TEXT, time_file INTEGER, time_build INTEGER,  rpm_license TEXT,  rpm_vendor TEXT,  rpm_group TEXT, rpm_buildhost TEXT,  rpm_sourcerpm TEXT,  rpm_header_start INTEGER,  rpm_header_end INTEGER,  rpm_packager TEXT,  size_package INTEGER,  size_installed INTEGER,  size_archive INTEGER,  location_href TEXT,  location_base TEXT,  checksum_type TEXT);");
  $dbh->do("CREATE TABLE files (  name TEXT,  type TEXT,  pkgKey INTEGER);");
  $dbh->do("CREATE TABLE requires (  name TEXT,  flags TEXT,  epoch TEXT,  version TEXT,  release TEXT,  pkgKey INTEGER , pre BOOLEAN DEFAULT FALSE);");
  $dbh->do("CREATE TABLE provides (  name TEXT,  flags TEXT,  epoch TEXT,  version TEXT,  release TEXT,  pkgKey INTEGER );");
  $dbh->do("CREATE TABLE conflicts (  name TEXT,  flags TEXT,  epoch TEXT,  version TEXT,  release TEXT,  pkgKey INTEGER );");
  $dbh->do("CREATE TABLE obsoletes (  name TEXT,  flags TEXT,  epoch TEXT,  version TEXT,  release TEXT,  pkgKey INTEGER );");
  $dbh->do("CREATE TRIGGER removals AFTER DELETE ON packages  BEGIN    DELETE FROM files WHERE pkgKey = old.pkgKey;    DELETE FROM requires WHERE pkgKey = old.pkgKey;    DELETE FROM provides WHERE pkgKey = old.pkgKey;    DELETE FROM conflicts WHERE pkgKey = old.pkgKey; DELETE FROM obsoletes WHERE pkgKey = old.pkgKey;  END;");
  $dbh->do("CREATE INDEX packagename ON packages (name);");
  $dbh->do("CREATE INDEX packageId ON packages (pkgId);");
  $dbh->do("CREATE INDEX filenames ON files (name);");
  $dbh->do("CREATE INDEX pkgfiles ON files (pkgKey);");
  $dbh->do("CREATE INDEX pkgrequires on requires (pkgKey);");
  $dbh->do("CREATE INDEX requiresname ON requires (name);");
  $dbh->do("CREATE INDEX pkgprovides on provides (pkgKey);");
  $dbh->do("CREATE INDEX providesname ON provides (name);");
  $dbh->do("CREATE INDEX pkgconflicts on conflicts (pkgKey);");
  $dbh->do("CREATE INDEX pkgobsoletes on obsoletes (pkgKey);");


  say "Looking for packages...";
  foreach my $pk ( $dom->find('package')->each ) {

    # insert package informatino
    my $sth = $dbh->prepare("INSERT INTO packages VALUES (NULL, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ? ,?, ?, ?, ?, ?)") or die "What the!";
    $sth->execute(
      $pk->at('checksum')->text,
      $pk->at('name')->text,
      $pk->at('arch')->text,
      $pk->at('version')->{ver},
      $pk->at('version')->{epoch},
      $pk->at('version')->{rel},
      $pk->at('summary')->text,
      $pk->at('description')->text,
      $pk->at('url')->text,
      $pk->at('time')->{file},
      $pk->at('time')->{build},
      $pk->at('format > rpm\:license')->text,
      $pk->at('format > rpm\:vendor')->text,
      $pk->at('format > rpm\:group')->text,
      $pk->at('format > rpm\:buildhost')->text,
      $pk->at('format > rpm\:sourcerpm')->text,
      $pk->at('format > rpm\:header-range')->{start},
      $pk->at('format > rpm\:header-range')->{end},
      $pk->at('packager')->text,
      $pk->at('size')->{package},
      $pk->at('size')->{installed},
      $pk->at('size')->{archive},
      $pk->at('location')->{href},
      $pk->at('location')->{base},
      $pk->at('checksum')->{type}
    );
    $sth->finish;

    my $pkgKey = $dbh->sqlite_last_insert_rowid();

    say "ID: $pkgKey";

    # insert files
    foreach my $f ( $pk->find('format > file')->each ) {
      my $sth = $dbh->prepare("INSERT INTO files VALUES (?, ?, ?)");
      $sth->execute(
        $f->text,
        '',
        $pkgKey
      );
      $sth->finish;
    }

    # insert requires
    foreach my $r ( $pk->find('format > rpm\:requires > rpm\:entry')->each ) {
      my $sth = $dbh->prepare("INSERT INTO requires VALUES (?, ?, ?, ?, ?, ?, ?)");
      $sth->execute(
        $r->{name},
        $r->{flags},
        $r->{epoch},
        $r->{version},
        $r->{release},
        $pkgKey,
        $r->{pre} // 0
      );
      $sth->finish;
    }

    # insert provides
    foreach my $p ( $pk->find('format > rpm\:provides > rpm\:entry')->each ) {
      my $sth = $dbh->prepare("INSERT INTO provides VALUES (?, ?, ?, ?, ?, ?)");
      $sth->execute(
        $p->{name},
        $p->{flags},
        $p->{epoch},
        $p->{version},
        $p->{release},
        $pkgKey
      );
      $sth->finish;
    }

    # insert conflicts
    foreach my $c ( $pk->find('format > rpm\:conflicts > rpm\:entry')->each ) {
      my $sth = $dbh->prepare("INSERT INTO conflicts VALUES (?, ?, ?, ?, ?, ?)");
      $sth->execute(
        $c->{name},
        $c->{flags},
        $c->{epoch},
        $c->{version},
        $c->{release},
        $pkgKey
      );
      $sth->finish;
    }

    # insert obsoletes
    foreach my $o ( $pk->find('format > rpm\:obsoletes > rpm\:entry')->each ) {
      my $sth = $dbh->prepare("INSERT INTO obsoletes VALUES (?, ?, ?, ?, ?, ?)");
      $sth->execute(
        $o->{name},
        $o->{flags},
        $o->{epoch},
        $o->{version},
        $o->{release},
        $pkgKey
      );
      $sth->finish;
    }
  }
}




#
# MAIN
#

foreach my $repo ( keys %$REPOS ) {
  my $r = $REPOS->{ $repo };

  foreach my $release ( @{ $r->{releases} } ) {
    foreach my $arch ( @{ $r->{archs} } ) {

      say 'Processing ' . join('-', $repo, $release, $arch) . " ...";
      my $url = $r->{url};

      # fill in variables
      $url =~ s/\$releasever/$release/g;
      $url =~ s/\$basearch/$arch/g;

      $url =~ s/^https/http/ if $NO_SSL;

      my $repomd = $url . "repodata/repomd.xml";
      my $attempt = 10;

      if( $r->{type} eq 'mirror-xml' ) {
        say 'Fetching XML mirror list: ' . $url;
        
        my $code = undef;
        my $tx;
	while( $attempt-- > 0 && ! defined $code ) {
	  $tx = $ua->get($url);
          $code = $tx->res->code;
          say " - " . $code;
        }

        my $dom = $tx->res->dom;
        $dom->xml(1);

        foreach my $f ( $dom->find('files file')->each ) {
          # we only care for the repomd.xml file
          next unless $f->{name} eq 'repomd.xml';

          foreach my $u ( $f->find('resources url')->each ) {
            next unless $u->{protocol} eq 'http';

            # we take the first hit due to priority sorting
            $repomd = $u->text;

            last;
          }
        }
      }
      elsif( $r->{type} eq 'mirror-plain' ) {
        my $tx = $ua->get($url);

        say 'Fetching PLAIN mirror list: ' . $url . " (" . $tx->res->code . ")";

        # TODO: this has changed in later MOJO versions, HACK for now
        if( $tx->res->to_string =~ m/^(http:.*)$/m ) {
          $repomd = $1 . "repodata/repomd.xml";
        }
      }

      $repomd =~ s/^https/http/ if $NO_SSL;

      say 'Fetching repomd.xml: ' . $repomd;

      $tx = $ua->get( $repomd );
      my $dom = $tx->res->dom;
      $dom->xml(1);

      my $db_url = '';

      my $completed = 0;

      foreach my $d ( $dom->find('data')->each ) {
        next unless $d->{type} eq 'primary_db';

        my $db_checksum = $d->at('checksum')->text;

        $db_href = $d->at('location')->{href};
        $db_href =~ s/repodata\///;

        # setup destination file
        my $db_bz2_path = $path . "/" . $arch . "/" . $release . "/" . $db_checksum . "." . $repo . ".sqlite.bz2";
        my $db_path     = $path . "/" . $arch . "/" . $release . "/" . $db_checksum . "." . $repo . ".sqlite";
        my $db_dir      = dirname $db_path;
        my @existing    = < "$path/$arch/$release/*.$repo.sqlite" >;

        $db_url = Mojo::URL->new( $repomd )->path( $db_href );

        # check if we already have it
        if( -r $db_path ) {
          say "Already have latest.";
          $completed = 1;
          last;
        };

        say 'Creating path: ' . $db_dir;
        make_path $db_dir;
      
        $db_url =~ s/^https/http/ if $NO_SSL;

        # check if we have the bz2
        unless( -r $db_bz2_path ) {
          # download file
          say 'Downloading: ' . $db_url;
          my $x = $ua->get($db_url);

          say 'Moving to: ' . $db_bz2_path;
          $x->res->content->asset->move_to( $db_bz2_path );
        }

        # decompress
        say 'Decompressing: ' . $db_bz2_path;
        bunzip2 $db_bz2_path => $db_path;

        # cleanup
        say 'Cleaning ...';
        unlink $db_bz2_path;
        unlink @existing;

        $completed = 1;
      }

      unless( $completed ) {
        say "No SQLITE formats available, falling back to XML and converting...";

        foreach my $d ( $dom->find('data')->each ) {
          next unless $d->{type} eq 'primary';

          my $db_checksum = $d->at('checksum')->text;

          $db_href = $d->at('location')->{href};
          $db_href =~ s/repodata\///;

          # setup destination file
          my $xml_gz_path = $path . "/" . $arch . "/" . $release . "/" . $db_checksum . "." . $repo . ".xml.gz";
          my $xml_path    = $path . "/" . $arch . "/" . $release . "/" . $db_checksum . "." . $repo . ".xml";
          my $db_path     = $path . "/" . $arch . "/" . $release . "/" . $db_checksum . "." . $repo . ".sqlite";
          my $db_dir      = dirname $db_path;
          my @existing    = < "$path/$arch/$release/*.$repo.sqlite" >;

          $db_url = Mojo::URL->new( $repomd )->path( $db_href );

          # check if we already have it
          if( -r $db_path ) {
            say "Already have latest.";
            $completed = 1;
            last;
          };

          say 'Creating path: ' . $db_dir;
          make_path $db_dir;

          # check if we have the gz
          unless( -r $xml_gz_path ) {
            # download file
            say 'Downloading: ' . $db_url;
            my $x = $ua->get($db_url);

            say 'Moving to: ' . $xml_gz_path;
            $x->res->content->asset->move_to( $xml_gz_path );
          }

          # decompress
          say 'Decompressing: ' . $xml_gz_path;
          gunzip $xml_gz_path => $xml_path;

          # Converting
          say 'Converting: ' . $xml_path . " => " . $db_path;
          convert $xml_path, $db_path;

          # cleanup
          say 'Cleaning ...';
          unlink $xml_gz_path;
          unlink $xml_path;
          unlink @existing;

          $completed = 1;
        }
      }

      unless( $completed ) {
        say "No SQLITE or XML formats available! Lame.";
      }

      say;
    }
  }
}




